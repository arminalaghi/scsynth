%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Copyright (C) 2016 N. Eamon Gaffney
%%
%% This program is free software; you can resdistribute and/or modify it under
%% the terms of the MIT license, a copy of which should have been included with
%% this program at https://github.com/arminalaghi/scsynth
%%
%% References:
%% W. Qian, X. Li, M. D. Riedel, K. Bazargan and D. J. Lilja, "An Architecture
%% for Fault-Tolerant Computation with Stochastic Logic," in IEEE Transactions
%% on Computers, vol. 60, no. 1, pp. 93-105, Jan. 2011.
%% doi: 10.1109/TC.2010.202
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function VerilogSCWrapperGenerator (coeff, N, m_input, m_coeff, randModule,
                                    ReSCModule, moduleName,
                                    singleWeightLFSR=true)

  %Generates a Verilog module that wraps an ReSC unit with conversions
  %from binary to stochastic on the inputs and from stochastic to binary
  %on the outputs.
  
  %Parameters:
  % coeff     : a list of coefficients of the Bernstein polynomial; each
  %             coefficient should fall within the unit interval
  % N         : the length of the stochastic bitstreams, must be a power of 2
  % m_input   : the length in bits of the input, at most log2(N)
  % m_coeff   : the length in bits of the coefficients, at most log2(N)
  % randModule: name of the randomizing Verilog module to be used for
  %             stochastic number generation
  % ReSCModule: name of the ReSC module to wrap
  % moduleName: the name of the verilog module
  
  %Optional Parameters:
  % singleWeightLFSR: Use the same LFSR for every constant. (Default true)
  
  m = log2(N);
  decimal_coeffs = round(coeff * 2^m_coeff) / (2^m_coeff) * N;
  degree = length(coeff) - 1;
  
	fileName = sprintf('%s.v', moduleName);
  header = "/*\n * This file was generated by the scsynth tool, and is availabl\
  efor use under\n * the MIT license. More information can be found at\n * http\
  s://github.com/arminalaghi/scsynth/\n */\n"
  
  fp = fopen(fileName, 'w');
  
  %declare module
  fprintf(fp, header);
  fprintf(fp, 'module %s( //handles stochastic/binary conversion for ReSC\n',
          moduleName);
	fprintf(fp, '\tinput [%d:0] x_bin, //binary value of input\n', m_input - 1);
  fprintf(fp, '\tinput start, //signal to start counting\n');
  fprintf(fp, '\toutput reg done, //signal that a number has been computed \n');
  fprintf(fp, '\toutput reg [%d:0] z_bin, //binary value of output\n\n', m - 1);
  
	fprintf(fp, '\tinput clk,\n');
	fprintf(fp, '\tinput reset\n');
  fprintf(fp, ');\n\n');

  if (m_input < m)
    fprintf(fp, '\twire [%d:0] x_bin_shifted;\n', m - 1);
    fprintf(fp, '\tassign x_bin_shifted = x_bin << %d;\n\n', m - m_input);
  end
  
  %define the constant coefficients
  fprintf(fp, '\t//the weights of the Bernstein polynomial\n');
  for i=0:degree
    fprintf(fp, "\treg [%d:0] w%d_bin = %d\'d%d;\n", m - 1, i, m,
            decimal_coeffs(i+1));
  end

  %declare internal wires
	fprintf(fp, '\n\twire [%d:0] x_stoch;\n', degree - 1);
	fprintf(fp, '\twire [%d:0] w_stoch;\n', degree);
	fprintf(fp, '\twire z_stoch;\n');
	fprintf(fp, '\twire init;\n');
	fprintf(fp, '\twire running;\n\n');

  %binary to stochastic conversion for the x values
  fprintf(fp, '\t//RNGs for binary->stochastic conversion\n'); 
  for i=0:degree - 1
    fprintf(fp, '\twire [%d:0] randx%d;\n', m - 1, i);
    fprintf(fp, '\t%s rand_gen_x_%d (\n', randModule, i);
		fprintf(fp, "\t\t.seed (%d'd%d),\n", m, round(N*i/(degree*2+1)));
		fprintf(fp, '\t\t.data (randx%d),\n', i);
		fprintf(fp, '\t\t.enable (running),\n');
		fprintf(fp, '\t\t.restart (init),\n');
		fprintf(fp, '\t\t.clk (clk),\n');
		fprintf(fp, '\t\t.reset (reset)\n');0
		fprintf(fp, '\t);\n');
    if (m_input < m)
      fprintf(fp, '\tassign x_stoch[%d] = randx%d < x_bin_shifted;\n\n', i, i);
    else
      fprintf(fp, '\tassign x_stoch[%d] = randx%d < x_bin;\n\n',  i, i);
    end
  end
  
  %binary to stochastic conversion for the coefficients
  if singleWeightLFSR
    fprintf(fp, '\twire [%d:0] randw;\n', m - 1);
    fprintf(fp, '\t%s rand_gen_w (\n', randModule);
	  fprintf(fp, "\t\t.seed (%d'd%d),\n", m, round(N * 2 / 3));
	  fprintf(fp, '\t\t.data (randw),\n');
	  fprintf(fp, '\t\t.enable (running),\n');
	  fprintf(fp, '\t\t.restart (init),\n');
	  fprintf(fp, '\t\t.clk (clk),\n');
	  fprintf(fp, '\t\t.reset (reset)\n');
	  fprintf(fp, '\t);\n');
    for i=0:degree
      fprintf(fp, '\tassign w_stoch[%d] = randw < w%d_bin;\n\n',  i, i);
    end
  else
    for i=0:degree
      fprintf(fp, '\twire [%d:0] randw%d;\n', m - 1, i);
      fprintf(fp, '\t%s rand_gen_w_%d (\n', randModule, i);
	  	fprintf(fp, "\t\t.seed (%d'd%d),\n", m, round(N*(i+degree)/(degree*2+1)));
	  	fprintf(fp, '\t\t.data (randw%d),\n', i);
	  	fprintf(fp, '\t\t.enable (running),\n');
	  	fprintf(fp, '\t\t.restart (init),\n');
	  	fprintf(fp, '\t\t.clk (clk),\n');
	  	fprintf(fp, '\t\t.reset (reset)\n');
	  	fprintf(fp, '\t);\n');
      fprintf(fp, '\tassign w_stoch[%d] = randw%d < w%d_bin;\n\n',  i, i, i);
    end
  end
    
  %initialize the core ReSC module
	fprintf(fp, '\t%s ReSC (\n', ReSCModule);
	fprintf(fp, '\t\t.x (x_stoch),\n');
	fprintf(fp, '\t\t.w (w_stoch),\n');
	fprintf(fp, '\t\t.z (z_stoch)\n');
	fprintf(fp, '\t);\n\n');

  %create finite state machine for handling  stochastic to binary conversion
  %and handshaking with the client
	fprintf(fp, '\treg [%d:0] count; //count clock cycles\n', m - 1');
	fprintf(fp, '\twire [%d:0] neg_one;\n', m - 1);
	fprintf(fp, '\tassign neg_one = -1;\n\n');

  fprintf(fp, '\t//Finite state machine. States:\n');
  fprintf(fp, '\t//0: finished, in need of resetting\n');
  fprintf(fp, '\t//1: initialized, start counting when start signal falls\n');
  fprintf(fp, '\t//2: running\n');
	fprintf(fp, '\treg [1:0] cs; //current FSM state\n');
	fprintf(fp, '\treg [1:0] ns; //next FSM state\n');
	fprintf(fp, '\tassign init = cs == 1;\n');
	fprintf(fp, '\tassign running = cs == 2;\n\n');

	fprintf(fp, '\talways @(posedge clk or posedge reset) begin\n');
	fprintf(fp, '\t\tif (reset) cs <= 0;\n');
	fprintf(fp, '\t\telse begin\n');
  fprintf(fp, '\t\t\tcs <= ns;\n');
	fprintf(fp, '\t\t\tif (running) begin\n');
	fprintf(fp, '\t\t\t\tif (count == neg_one) done <= 1;\n');
	fprintf(fp, '\t\t\t\tcount <= count + 1;\n');
	fprintf(fp, '\t\t\t\tz_bin <= z_bin + z_stoch;\n');
	fprintf(fp, '\t\t\tend\n');
	fprintf(fp, '\t\tend\n');
	fprintf(fp, '\tend\n\n');

	fprintf(fp, '\talways @(*) begin\n');
	fprintf(fp, '\t\tcase (cs)\n');
	fprintf(fp, '\t\t\t0: if (start) ns = 1; else ns = 0;\n');
	fprintf(fp, '\t\t\t1: if (start) ns = 1; else ns = 2;\n');
	fprintf(fp, '\t\t\t2: if (done) ns = 0; else ns = 2;\n');
	fprintf(fp, '\t\t\tdefault ns = 0;\n');
	fprintf(fp, '\t\tendcase\n');
	fprintf(fp, '\tend\n\n');

	fprintf(fp, '\talways @(posedge init) begin\n');
	fprintf(fp, '\t\tcount <= 0;\n');
	fprintf(fp, '\t\tz_bin <= 0;\n');
	fprintf(fp, '\t\tdone <= 0;\n');
	fprintf(fp, '\tend\n');
  fprintf(fp, 'endmodule\n');

  fclose(fp);
end
