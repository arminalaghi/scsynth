%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Copyright (C) 2016 N. Eamon Gaffney
%%
%% This program is free software; you can resdistribute and/or modify it under
%% the terms of the MIT license, a copy of which should have been included with
%% this program at https://github.com/arminalaghi/scsynth
%%
%% References:
%% Qian, W., Li, X., Riedel, M. D., Bazargan, K., & Lilja, D. J. (2011). An
%% Architecture for Fault-Tolerant Computation with Stochastic Logic. IEEE
%% Transactions on Computers IEEE Trans. Comput., 60(1), 93-105.
%% doi:10.1109/tc.2010.202
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function VerilogCoreReSCGenerator (degree, moduleName,...
                                   hardCodeConstants=true,...
                                   singleConstantBitstream=true, coeff=[],...
                                   m_coeff=0)

  %Generates an ReSC module in verilog whose inputs and outputs
  %remain in stochastic format

  %Parameters:
  % degree    : the degree of the Bernstein polynomial
  % moduleName: the name of the verilog module

  %Optional Parameters:
  % hardCodeConstants: if true, constant input is simply a random bitstream, and
  %                    stochastic number generation is hard coded into the
  %                    module (default=true)
  % singleConstantBitstream: only relevant if hardCodeConstants is true, if true,
  %                         use one random bitstream for all constants rather
  %                         than an independent one for each (default true)
  % coeff: Bernstein coefficients, required with hardCodeConstants and
  %        unnecessary otherwise
  % m_coeff: number of bits in representation of coefficients, required with
  %          hardCodeConstants, unnecessary otherwise

  fileName = sprintf('%s.v', moduleName);
  header = ['/*\n * This file was generated by the scsynth tool, and is ava',...
            'ilable for use under\n * the MIT license. More information can ',...
            'be found at\n * https://github.com/arminalaghi/scsynth/\n */\n'];

  fp = fopen(fileName, 'w');

  fprintf(fp, header);
  fprintf(fp, 'module %s( //the stochastic core of an ReSC\n', moduleName);
	fprintf(fp, '\tinput [%d:0] x, //independent copies of x\n', degree - 1);
  if hardCodeConstants
    if singleConstantBitstream
      fprintf(fp, '\tinput [%d:0] randw, //for constant generation\n', m_coeff-1);
    else
      for i=0:degree
        fprintf(fp, '\tinput [%d:0] randw%d, //for constant generation\n', i,...
                m_coeff-1);
      end
    end
  else
    fprintf(fp, '\tinput [%d:0] w, //Bernstein coefficients\n', degree);
  end
  fprintf(fp, '\toutput reg z //output bitsream\n);\n\n');

  if hardCodeConstants
    prob_table = zeros(1, 4);
    for i=0:degree
		  fprintf(fp, '\twire wire%d_1;\n', i);
      temp = round(coeff(i+1)*(2^m_coeff))/(2^m_coeff);
      for j=1:m_coeff+1
        if(temp == 1)
          fprintf(fp, '\tassign wire%d_%d = 1;\n', i, j);
          break;
        elseif(temp == 0)
          fprintf(fp, '\tassign wire%d_%d = 0;\n', i, j);
          break;
        else
          if(size(find(prob_table(:, 1) == temp), 1) ~= 0) %prob exists
            index = find(prob_table(:, 1) == temp);
            temp2 = prob_table(index, :);
            if(size(find(temp2(:, 2) == j), 1) ~= 0) %the same level
              index2 = find(temp2(:, 2) == j);
              temp2 = temp2(index2, :);
              fprintf(fp, '\tassign wire%d_%d = wire%d_%d;\n', i, j,...
                      temp2(1, 3), temp2(1, 4));
              break;
            end
          end

          if(size(find(prob_table(:, 1) == 1 - temp), 1) ~= 0) %inverse
            index = find(prob_table(:, 1) == 1 - temp);
            temp2 = prob_table(index, :);
            if(size(find(temp2(:, 2) == j), 1) ~= 0) %the same level
              index2 = find(temp2(:, 2) == j);
              temp2 = temp2(index2, :);
              fprintf(fp, '\tassign wire%d_%d = ~wire%d_%d;\n', i, j,...
                      temp2(1, 3), temp2(1, 4));
              break;
            end
          end

          new_row = [temp, j, i, j];
          prob_table = [prob_table ; new_row];
          if singleConstantBitstream
            rand = 'randw';
          else
            rand = sprintf('randw%d', i);
          end
          if(temp < 0.5)
            fprintf(fp, '\twire wire%d_%d;\n', i, j+1);
            fprintf(fp, '\tassign wire%d_%d = (%s[%d] & wire%d_%d);\n', i, j,...
                    rand, m_coeff - j, i, j+1);
            temp = 2*temp;
          else
            fprintf(fp, '\twire wire%d_%d;\n', i, j+1);
            fprintf(fp, '\tassign wire%d_%d = (%s[%d] | wire%d_%d);\n', i, j,...
                    rand, m_coeff - j, i, j+1);
            temp = 2*temp - 1;
          end
        end
      end
      fprintf(fp, '\n');
    end
  end

  bits = ceil(log2(degree));
  % The minimum value of any bit should be 1
  if(bits < 1)
    bits = 1;
  end
  fprintf(fp, '\twire [%d:0] sum; //sum of x values for mux\n', bits - 1);
  fprintf(fp, '\tassign sum = x[0]');
  for i=1:degree - 1
    fprintf(fp, ' + x[%d]', i);
  end
  fprintf(fp, ';\n\n');

  fprintf(fp, '\talways @(*) begin\n');
  fprintf(fp, '\t\tcase (sum)\n');
  for i=0:degree
    if hardCodeConstants
      fprintf(fp, '\t\t\t%d''d%d: z = wire%d_1;\n', bits, i, i);
    else
      fprintf(fp, '\t\t\t%d''d%d: z = w[%d];\n', bits, i, i);
    end
  end
  fprintf(fp, '\t\t\tdefault: z = 0;\n');
  fprintf(fp, '\t\tendcase\n');
  fprintf(fp, '\tend\n');
  fprintf(fp, 'endmodule\n');

  fclose(fp);
end
