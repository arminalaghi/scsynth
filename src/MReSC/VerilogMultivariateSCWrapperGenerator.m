%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Copyright (C) 2016 N. Eamon Gaffney
%%
%% This program is free software; you can resdistribute and/or modify it under
%% the terms of the MIT license, a copy of which should have been included with
%% this program at https://github.com/arminalaghi/scsynth
%%
%% References:
%% Qian, W., Li, X., Riedel, M. D., Bazargan, K., & Lilja, D. J. (2011). An
%% Architecture for Fault-Tolerant Computation with Stochastic Logic. IEEE
%% Transactions on Computers IEEE Trans. Comput., 60(1), 93-105.
%% doi:10.1109/tc.2010.202
%%
%% Qian, W., & Riedel, M.D.. (2010). The Synthesis of Stochastic Logic to
%% Perform Multivariate Polynomial Arithmetic.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function VerilogMultivariateSCWrapperGenerator (coeff, degrees, N, m_input,
                                                m_coeff, randModule, ReSCModule,
                                                moduleName,
                                                singleWeightLFSR=true)

  %Generates a Verilog module that wraps an ReSC unit with conversions
  %from binary to stochastic on the inputs and from stochastic to binary
  %on the outputs.
  
  %Parameters:
  % coeff     : a list of coefficients of the Bernstein polynomial, ordered
  %             w_0_0..._0, w_0_0..._1, ..., w_0_0..._1_0, etc.; each
  %             coefficient should fall within the unit interval
  % degrees   : the degrees of the component Bernstein polynomials in order
  % N         : the length of the stochastic bitstreams, must be a power of 2
  % m_input   : the length in bits of the input, at most log2(N)
  % m_coeff   : the length in bits of the coefficients, at most log2(N)
  % randModule: name of the randomizing Verilog module to be used for
  %             stochastic number generation
  % ReSCModule: name of the ReSC module to wrap
  % moduleName: the name of the verilog module
  
  %Optional Parameters:
  % singleWeightLFSR: Use the same LFSR for every constant. (Default true)
  
  m = log2(N);
  decimal_coeffs = round(coeff * 2^m_coeff) / (2^m_coeff) * N;
  
	fileName = sprintf('%s.v', moduleName);
  header = "/*\n * This file was generated by the scsynth tool, and is availabl\
efor use under\n * the MIT license. More information can be found at\n * https:\
//github.com/arminalaghi/scsynth/\n */\n"
  
  fp = fopen(fileName, 'w');
  
  %declare module
  fprintf(fp, header);
  fprintf(fp, 'module %s( //handles stochastic/binary conversion for ReSC\n',
          moduleName);
  for i=1:length(degrees)
	  fprintf(fp, '\tinput [%d:0] x_%d_bin, //binary value of input %d\n',
            m_input - 1, i, i);
  end
  fprintf(fp, '\tinput start, //signal to start counting\n');
  fprintf(fp, '\toutput reg done, //signal that a number has been computed \n');
  fprintf(fp, '\toutput reg [%d:0] z_bin, //binary value of output\n\n', m - 1);
  
	fprintf(fp, '\tinput clk,\n');
	fprintf(fp, '\tinput reset\n');
  fprintf(fp, ');\n\n');

  if (m_input < m)
    for i=1:length(degrees)
      fprintf(fp, '\twire [%d:0] x_%d_bin_shifted;\n', m - 1, i);
      fprintf(fp, '\tassign x_%d_bin_shifted = x_%d_bin << %d;\n\n', i, i,
              m - m_input);
    end
  end
  
  %define the constant coefficients
  fprintf(fp, '\t//the weights of the Bernstein polynomial\n');
  for i=0:length(coeff) - 1
    fprintf(fp, "\treg [%d:0] w%d_bin = %d\'d%d;\n", m - 1, i, m,
            decimal_coeffs(i+1));
  end

  %declare internal wires
  for i=1:length(degrees)
	  fprintf(fp, '\n\twire [%d:0] x_%d_stoch;\n', degrees(i) - 1, i);
	end
  fprintf(fp, '\twire [%d:0] w_stoch;\n', length(coeff) - 1);
	fprintf(fp, '\twire z_stoch;\n');
	fprintf(fp, '\twire init;\n');
	fprintf(fp, '\twire running;\n\n');

  %binary to stochastic conversion for the x values
  fprintf(fp, '\t//RNGs for binary->stochastic conversion\n'); 
  for i=1:length(degrees)
    for j=0:degrees(i) - 1
      fprintf(fp, '\twire [%d:0] randx_%d_%d;\n', m - 1, i, j);
      fprintf(fp, '\t%s rand_gen_x_%d_%d (\n', randModule, i, j);
		  fprintf(fp, "\t\t.seed (%d'd%d),\n", m, round(N*j/(degrees(i)*2+1)));
	  	fprintf(fp, '\t\t.data (randx_%d_%d),\n', i, j);
	  	fprintf(fp, '\t\t.enable (running),\n');
	  	fprintf(fp, '\t\t.restart (init),\n');
	  	fprintf(fp, '\t\t.clk (clk),\n');
	  	fprintf(fp, '\t\t.reset (reset)\n');0
	  	fprintf(fp, '\t);\n');
      if (m_input < m)
        fprintf(fp, '\tassign x_%d_stoch[%d] = randx_%d_%d < x_%d_bin_shifted;\n\n',
                i, j, i, j, i);
      else
        fprintf(fp, '\tassign x_%d_stoch[%d] = randx_%d_%d < x_%d_bin;\n\n',  i,
                j, i, j, i);
      end
    end
  end
  
  %binary to stochastic conversion for the coefficients
  if singleWeightLFSR
    fprintf(fp, '\twire [%d:0] randw;\n', m - 1);
    fprintf(fp, '\t%s rand_gen_w (\n', randModule);
	  fprintf(fp, "\t\t.seed (%d'd%d),\n", m, round(N * 2 / 3));
	  fprintf(fp, '\t\t.data (randw),\n');
	  fprintf(fp, '\t\t.enable (running),\n');
	  fprintf(fp, '\t\t.restart (init),\n');
	  fprintf(fp, '\t\t.clk (clk),\n');
	  fprintf(fp, '\t\t.reset (reset)\n');
	  fprintf(fp, '\t);\n');
    for i=0:length(coeff) - 1
      fprintf(fp, '\tassign w_stoch[%d] = randw < w%d_bin;\n\n',  i, i);
    end
  else
    for i=0:length(coeff) - 1
      fprintf(fp, '\twire [%d:0] randw%d;\n', m - 1, i);
      fprintf(fp, '\t%s rand_gen_w_%d (\n', randModule, i);
	  	fprintf(fp, "\t\t.seed (%d'd%d),\n", m, round(N*(i+degree)/(degree*2+1)));
	  	fprintf(fp, '\t\t.data (randw%d),\n', i);
	  	fprintf(fp, '\t\t.enable (running),\n');
	  	fprintf(fp, '\t\t.restart (init),\n');
	  	fprintf(fp, '\t\t.clk (clk),\n');
	  	fprintf(fp, '\t\t.reset (reset)\n');
	  	fprintf(fp, '\t);\n');
      fprintf(fp, '\tassign w_stoch[%d] = randw%d < w%d_bin;\n\n',  i, i, i);
    end
  end
    
  %initialize the core ReSC module
	fprintf(fp, '\t%s ReSC (\n', ReSCModule);
  for i=1:length(degrees)
	  fprintf(fp, '\t\t.x_%d (x_%d_stoch),\n', i, i);
  end
	fprintf(fp, '\t\t.w (w_stoch),\n');
	fprintf(fp, '\t\t.z (z_stoch)\n');
	fprintf(fp, '\t);\n\n');

  %create finite state machine for handling stochastic to binary conversion
  %and handshaking with the client
	fprintf(fp, '\treg [%d:0] count; //count clock cycles\n', m - 1');
	fprintf(fp, '\twire [%d:0] neg_one;\n', m - 1);
	fprintf(fp, '\tassign neg_one = -1;\n\n');

  fprintf(fp, '\t//Finite state machine. States:\n');
  fprintf(fp, '\t//0: finished, in need of resetting\n');
  fprintf(fp, '\t//1: initialized, start counting when start signal falls\n');
  fprintf(fp, '\t//2: running\n');
	fprintf(fp, '\treg [1:0] cs; //current FSM state\n');
	fprintf(fp, '\treg [1:0] ns; //next FSM state\n');
	fprintf(fp, '\tassign init = cs == 1;\n');
	fprintf(fp, '\tassign running = cs == 2;\n\n');

	fprintf(fp, '\talways @(posedge clk or posedge reset) begin\n');
	fprintf(fp, '\t\tif (reset) cs <= 0;\n');
	fprintf(fp, '\t\telse begin\n');
  fprintf(fp, '\t\t\tcs <= ns;\n');
	fprintf(fp, '\t\t\tif (running) begin\n');
	fprintf(fp, '\t\t\t\tif (count == neg_one) done <= 1;\n');
	fprintf(fp, '\t\t\t\tcount <= count + 1;\n');
	fprintf(fp, '\t\t\t\tz_bin <= z_bin + z_stoch;\n');
	fprintf(fp, '\t\t\tend\n');
	fprintf(fp, '\t\tend\n');
	fprintf(fp, '\tend\n\n');

	fprintf(fp, '\talways @(*) begin\n');
	fprintf(fp, '\t\tcase (cs)\n');
	fprintf(fp, '\t\t\t0: if (start) ns = 1; else ns = 0;\n');
	fprintf(fp, '\t\t\t1: if (start) ns = 1; else ns = 2;\n');
	fprintf(fp, '\t\t\t2: if (done) ns = 0; else ns = 2;\n');
	fprintf(fp, '\t\t\tdefault ns = 0;\n');
	fprintf(fp, '\t\tendcase\n');
	fprintf(fp, '\tend\n\n');

	fprintf(fp, '\talways @(posedge init) begin\n');
	fprintf(fp, '\t\tcount <= 0;\n');
	fprintf(fp, '\t\tz_bin <= 0;\n');
	fprintf(fp, '\t\tdone <= 0;\n');
	fprintf(fp, '\tend\n');
  fprintf(fp, 'endmodule\n');

  fclose(fp);
end
